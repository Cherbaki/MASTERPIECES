#include <iostream>

typedef int T;
class AVLT {

	class Node {
	public:
		T data;
		Node* left, * right = NULL,*parent = NULL;
		Node(T Data, Node* LeftC = NULL, Node* Right = NULL, Node* Parent = NULL)
			:left(LeftC), right(Right), parent(Parent),data(Data) {}
			
	};
	Node* root = NULL;
public:
	
	//Default constructor
	AVLT() = default;
	
	//Initialiser list constructor
	AVLT(std::initializer_list<T> list) {
		for (auto item : list)
			Insert(item);
	}

	//Recursively inserting items in the AVLT
	void Insert(T data) {
		InsertionHelper(root, data);
	}

	//Inorder Display
	void Display() {
		DisplayHelper(this->root);
		std::cout << std::endl;
	}

	//Deletes given item from AVLT if it's there
	void Delete(T data) {
		DeleteionHelper(root,data);
	}

	int GetHeight() {
		Node* HeadOfSubTree = root;
		int counter = -1;
		while (HeadOfSubTree != NULL) {
			HeadOfSubTree = HeadOfSubTree->left;
			counter++;
		}
		return counter;
	}

private:
	//Insertiong helper
	void InsertionHelper(Node*& Root,T data) {
		
		if (Root == NULL)
			Root = new Node(data); 
		else if (data > Root->data)
			InsertionHelper(Root->right, data);
		else if (data < Root->data)
			InsertionHelper(Root->left, data);
		else{
			std::cout << "Item is already in AVLT" << std::endl;
			return;
		}

		//Starting balancing the tree if needed
		int BalanceFactor = GetBalanceFactor(Root);
		

		if (BalanceFactor > 1 && data < Root->left->data)//If tree is LeftLeft inbalance
			RightRotate(Root);
		else if(BalanceFactor < -1 && data > Root->right->data)//if tree is RightRight inbalance
			LeftRotate(Root);
		else if(BalanceFactor > 1 && data > Root->left->data){//If tree is LeftRight inbalance
			LeftRotate(Root->left);
			RightRotate(Root);
		}
		else if (BalanceFactor < -1 && data < Root->right->data) {//If tree is RightLeft inbalance
			RightRotate(Root->right);
			LeftRotate(Root);
		}

	}

	//Right rotation
	void RightRotate(Node*& Root) {
		Node* LeftChild = Root->left;
		Node* LeftsRight = LeftChild->right;
		//Performing rotation
		LeftChild->right = Root;
		Root->left = LeftsRight;
		Root = LeftChild;
	}
	//Left rotation
	void LeftRotate(Node*& Root) {
		Node* RightChild = Root->right;
		Node* RightsLeft = RightChild->left;
		//Performing rotation
		RightChild->left = Root;
		Root->right = RightsLeft;
		Root = RightChild;
	}

	//Inorder display helper
	void DisplayHelper(Node* root) {
		if (root == NULL)
			return;
		DisplayHelper(root->left);
		std::cout << root->data << "\t";
		DisplayHelper(root->right);
	}

	//Calculates and returns height of the given subtree
	int GetHeight(Node* HeadOfSubTree) {
		int counter = -1;
		while (HeadOfSubTree != NULL){
			HeadOfSubTree = HeadOfSubTree->left;
			counter++;
		}
		return counter;
	}

	//Deletiong helper
	void DeleteionHelper(Node*& Root,T data) {
		//Firstly we want to fine the node
		if (Root == NULL) {
			std::cout << "Elemnt is not in AVLT" << std::endl;
			return;
		}
		if (Root->data > data)
			DeleteionHelper(Root->left, data);
		else if (Root->data < data)
			DeleteionHelper(Root->right, data);

		//At this point we found the node, Time to delete
		//Case 1 and case 2 can be united likewise
		if (Root->left == NULL) {
			Node* temp = Root;
			Root = Root->right;
			delete temp;
		}
		else if (Root->right == NULL) {
			Node* temp = Root;
			Root = Root->left;
			delete temp;
		}
		//Case 3
		else if(Root->right != NULL && Root->left != NULL) {
			Node* MaxFromLeftSubTree = FindMaxFromLeft(Root);
			Root->data = MaxFromLeftSubTree->data;
			delete MaxFromLeftSubTree;
		}


	}

	//Finds Maximum value from leftSubTree
	Node*& FindMaxFromLeft(Node* RootsLeft) {
		while (RootsLeft->right != NULL)
			RootsLeft = RootsLeft->right;
		return RootsLeft;
	}

	//Calculates and returns a BalanceFactor for given node
	int GetBalanceFactor(Node* Root) {
		if (Root == NULL)
			return -1;
		return (GetHeight(Root->left) - GetHeight(Root->right));
	}
};